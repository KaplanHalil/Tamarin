theory first_example

begin

builtins: hashing, asymmetric-encryption

/*
  * ~x denotes x:fresh
  * $x denotes x:pub
  * %x denotes x:nat
  * #i denotes i:temporal
  * m denotes m:msg
  * ! denotes that the fact is persistent, 
    i.e., it can be consumed arbitrarily often
  * !Ltk($A, ~ltk) denotes the association between 
    agent A and its private key ~ltk
  * !Pk($A, pk(~ltk)) associates 
    agent A and its public key pk(~ltk)
  
  -------------------------------------------------------

  Note that # denotes a temporal variable and @i can be read as ”at time
  point i”. Also note that @i is short for @ #i.

  -------------------------------------------------------

  The actual labeled rewriting rule is specified with an arrow
  notation, [ ] --[ ]-> [ ] where the first bracket specifies the premise facts which
  the rule consumes, the second optional bracket specifies the action facts which are
  created upon application of the rule and the third and last bracket is used for specifying
  the conclusion facts which are created by application of the rule.

  1 rule Rule Identifier :
  2 [ Premise Facts ]
  3 --[ Action Facts ]->
  4 [ Conclusion Facts ]

  -------------------------------------------------------

 */

rule Register_pk:
[ Fr(~ltk) ]
-->
[ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)) ]

/* 
C -> S: aenc(k, pkS)
C <- S: h(k)
We model it using the following three rules.

*/

// Start a new thread executing the client role, choosing the server
// non-deterministically.
rule Client_1:
[ Fr(~k) // choose fresh key
, !Pk($S, pkS) // lookup public-key of server
]
-->
[ Client_1( $S, ~k ) // Store server and key for next step of thread
, Out( aenc(~k, pkS) ) // Send the encrypted session key to the server
]
rule Client_2:
[ Client_1(S, k) // Retrieve server and session key from previous step
, In( h(k) ) // Receive hashed session key from network
]
--[ SessKeyC( S, k ) ]-> // State that the session key 'k'
[] // was setup with server 'S'
// A server thread answering in one-step to a session-key setup request from
// some client.
rule Serv_1:
[ !Ltk($S, ~ltkS) // lookup the private-key
, In( request ) // receive a request
]
--[ AnswerRequest($S, adec(request, ~ltkS)) ]-> // Explanation below
[ Out( h(adec(request, ~ltkS)) ) ] // Return the hash of the
// decrypted request.