// This is a toy protocol used to play around

/*
Alex computes a nonce and sends it to Blake. (A -> B: ANonce)
When Blake receives Alex's nonce, Blake computes their own nonce and sends it to Alex. (B -> A: BNonce)
When Alex receives Blake's nonce, Alex does two things:
Alex installs a session key SK, which is derived from ANonce and BNonce by applying a key derivation function (i.e., SK = kdf(ANonce, BNonce)).
Once the session key is installed, Alex sends a message with the string "ACK" to Blake (A -> B: "ACK") and switches to a 'DONE' state to indicate that the 
protocol has been executed successfully on Alex's side.
When Blake receives the "ACK" message, Blake also computes the session key SK = kdf(ANonce, BNonce), installs it and switches to a 'DONE' state.
*/





theory toy_protocol
begin

functions: kdf/2
builtins: symmetric-encryption

// BEGIN Rules

rule Init:
    [ Fr(~aID), Fr(~bID) ]
    --[ Init(~aID, ~bID) ]->
    [ AState(~aID, 'INIT', 'EMPTY_STATE')
    , BState(~bID, 'INIT', 'EMPTY_STATE') ]

rule ASendNonce [color=#ffdea6]:
    [ AState(~aID, 'INIT', 'EMPTY_STATE')
    , Fr(~ANonce) ]
    --[ ASendsNonce(~aID, ~ANonce) ]->
    [ AState(~aID, 'SENT_NONCE', ~ANonce)
    , Out(~ANonce) ]

rule AReceiveNonceInstallKey [color=#ffdea6]:
    let 
        SK = kdf(~ANonce, BNonce)
    in
    [ AState(~aID, 'SENT_NONCE', ~ANonce)
    , In(BNonce) ]
    --[ AInstallsKey(~aID, ~ANonce, BNonce, SK) ]->
    [ AState(~aID, 'INSTALLED_KEY', <~ANonce, BNonce, SK>)
    , Out('ACK') ]

rule BReceiveNonceSendNonce [color=#b5f5f7]:
    [ BState(~bID, 'INIT', 'EMPTY_STATE')
    , Fr(~BNonce)
    , In(ANonce) ]
    --[ BReceivesNonceSendsNonce(~bID, ANonce, ~BNonce) ]->
    [ BState(~bID, 'SENT_NONCE', <ANonce, ~BNonce>)
    , Out(~BNonce) ]

rule BReceiveAckInstallKey [color=#b5f5f7]:
    let
        SK = kdf(ANonce, ~BNonce)
    in
    [ BState(~bID, 'SENT_NONCE', <ANonce, ~BNonce>)
    , In('ACK') ]
    --[ BInstallsKey(~bID, ANonce, ~BNonce, SK) ]->
    [ BState(~bID, 'INSTALLED_KEY', <ANonce, ~BNonce, SK>) ]

// END Rules

// BEGIN Statements

lemma successful_run: exists-trace
    "Ex bID aID ANonce BNonce SK #i #j.
        AInstallsKey(bID, ANonce, BNonce, SK) @ i &
        BInstallsKey(aID, ANonce, BNonce, SK) @ j"

lemma sk_secret_a:
    "All aID ANonce BNonce SK #i. 
        AInstallsKey(aID, ANonce, BNonce, SK) @ i 
            ==> not(Ex #j. K(SK) @ j)"

lemma sk_secret_b:
    "All bID ANonce BNonce SK #i. 
        BInstallsKey(bID, ANonce, BNonce, SK) @ i 
            ==> not(Ex #j. K(SK) @ j)"

// END Statements

end